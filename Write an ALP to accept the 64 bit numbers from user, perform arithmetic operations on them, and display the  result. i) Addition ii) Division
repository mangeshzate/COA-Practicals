%macro WRITE 2
    mov rax,1
    mov rdi,1
    mov rsi,%1
    mov rdx,%2
    syscall
%endmacro

%macro READ 2
    mov rax,0
    mov rdi,0
    mov rsi,%1
    mov rdx,%2
    syscall
%endmacro

%macro EXIT 0
    mov rax,60
    mov rdi,0
    syscall
%endmacro

section .data
msg1 db "Enter first 64-bit hex number: ",10
len1 equ $-msg1
msg2 db "Enter second 64-bit hex number: ",10
len2 equ $-msg2

msg_add db 10,"Addition = ",10
len_add equ $-msg_add
msg_divq db 10,"Quotient = ",10
len_divq equ $-msg_divq
msg_divr db "Remainder = ",10
len_divr equ $-msg_divr
msg_div0 db "Error: Division by zero!",10
len_div0 equ $-msg_div0

section .bss
 A resq 1
 B resq 1
 Q resq 1
 R resq 1
 buf resb 32

section .text
global _start

_start:
    ; ---- INPUT ----
    WRITE msg1,len1
    READ buf,17
    call accept
    mov [A],rbx

    WRITE msg2,len2
    READ buf,17
    call accept
    mov [B],rbx

    ; ---- ADDITION ----
    mov rax,[A]
    add rax,[B]
    mov [Q],rax

    WRITE msg_add,len_add
    mov rbx,[Q]
    call display

    ; ---- DIVISION ----
    cmp qword[B],0
    je div_zero

    mov rdx,0
    mov rax,[A]
    div qword[B]
    mov [Q],rax
    mov [R],rdx

    WRITE msg_divq,len_divq
    mov rbx,[Q]
    call display

    WRITE msg_divr,len_divr
    mov rbx,[R]
    call display

    EXIT

div_zero:
    WRITE msg_div0,len_div0
    EXIT


; ===== accept hex â†’ RBX =====
accept:
    mov rsi,buf
    xor rbx,rbx
    mov rcx,16
.loop:
    mov al,[rsi]
    cmp al,0x39
    jbe .num
    sub al,7
.num:
    sub al,0x30
    shl rbx,4
    or  rbx,rax
    inc rsi
    loop .loop
    ret

; ===== display RBX (16 hex chars) =====
display:
    mov rcx,16
    mov rsi,buf
.loop2:
    rol rbx,4
    mov al,bl
    and al,0x0F
    cmp al,9
    jbe .num2
    add al,7
.num2:
    add al,0x30
    mov [rsi],al
    inc rsi
    loop .loop2
    WRITE buf,16
    ret
